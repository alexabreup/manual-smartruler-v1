---
// Visualizador 3D Simples e Funcional
---

<div id="three-container-simple" class="smart-ruler-viewer">
  <div id="loading-simple">Carregando modelo 3D...</div>
</div>

<style>
  .smart-ruler-viewer {
    width: 100%;
    height: 600px;
    border-radius: 8px;
    overflow: hidden;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    position: relative;
    margin: 2rem 0;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
  }

  #loading-simple {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-size: 18px;
    font-weight: 600;
    z-index: 10;
    text-align: center;
  }

  #loading-simple.hidden {
    display: none;
  }

  .controls-info {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    z-index: 20;
  }
</style>

<!-- Three.js r128 - Vers√£o est√°vel -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
  function initSimpleViewer() {
    // Verificar se Three.js carregou
    if (typeof THREE === 'undefined') {
      setTimeout(initSimpleViewer, 100);
      return;
    }

    const container = document.getElementById('three-container-simple');
    const loading = document.getElementById('loading-simple');
    
    if (!container) return;

    try {
      // Setup b√°sico
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);

      const camera = new THREE.PerspectiveCamera(
        45,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.set(5, 5, 8);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);

      // Controles simples com mouse
      let mouseDown = false;
      let mouseX = 0;
      let mouseY = 0;
      let targetRotationX = 0;
      let targetRotationY = 0;
      let rotationX = 0;
      let rotationY = 0;

      container.addEventListener('mousedown', (event) => {
        mouseDown = true;
        mouseX = event.clientX;
        mouseY = event.clientY;
      });

      container.addEventListener('mousemove', (event) => {
        if (!mouseDown) return;
        
        const deltaX = event.clientX - mouseX;
        const deltaY = event.clientY - mouseY;
        
        targetRotationY += deltaX * 0.01;
        targetRotationX += deltaY * 0.01;
        
        mouseX = event.clientX;
        mouseY = event.clientY;
      });

      container.addEventListener('mouseup', () => {
        mouseDown = false;
      });

      container.addEventListener('wheel', (event) => {
        event.preventDefault();
        const scale = event.deltaY > 0 ? 1.1 : 0.9;
        camera.position.multiplyScalar(scale);
      });

      // Ilumina√ß√£o
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
      directionalLight2.position.set(-5, 3, -5);
      scene.add(directionalLight2);

      // Criar Smart Ruler
      const smartRuler = createSmartRulerSimple();
      scene.add(smartRuler);

      // Adicionar controles de informa√ß√£o
      const controlsInfo = document.createElement('div');
      controlsInfo.className = 'controls-info';
      controlsInfo.innerHTML = 'üñ±Ô∏è Arrastar: Rotacionar | üîÑ Scroll: Zoom';
      container.appendChild(controlsInfo);

      if (loading) loading.classList.add('hidden');

      // Loop de anima√ß√£o
      function animate() {
        requestAnimationFrame(animate);
        
        // Suavizar rota√ß√£o
        rotationX += (targetRotationX - rotationX) * 0.1;
        rotationY += (targetRotationY - rotationY) * 0.1;
        
        smartRuler.rotation.x = rotationX;
        smartRuler.rotation.y = rotationY;
        
        // Auto-rota√ß√£o suave
        if (!mouseDown) {
          targetRotationY += 0.005;
        }
        
        renderer.render(scene, camera);
      }
      animate();

      // Responsivo
      window.addEventListener('resize', () => {
        if (!container) return;
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });

    } catch (error) {
      console.error('Erro ao inicializar visualizador:', error);
      if (loading) {
        loading.textContent = 'Erro ao carregar visualizador 3D';
      }
    }
  }

  function createSmartRulerSimple() {
    const group = new THREE.Group();

    // Base principal
    const baseGeometry = new THREE.BoxGeometry(0.8, 2.8, 0.12);
    const baseMaterial = new THREE.MeshLambertMaterial({
      color: 0x2a2a2a
    });
    const base = new THREE.Mesh(baseGeometry, baseMaterial);
    group.add(base);

    // Criar 4 tomadas
    const socketPositions = [
      { y: 1.05, active: true },
      { y: 0.35, active: true },
      { y: -0.35, active: true },
      { y: -1.05, active: false }
    ];

    socketPositions.forEach((pos, index) => {
      const socket = createSocketSimple(pos.active);
      socket.position.set(0, pos.y, 0.07);
      group.add(socket);
    });

    return group;
  }

  function createSocketSimple(isActive) {
    const socketGroup = new THREE.Group();
    const baseColor = isActive ? 0xFF5722 : 0x3a3a3a;

    // Base da tomada
    const socketGeometry = new THREE.BoxGeometry(0.5, 0.4, 0.06);
    const socketMaterial = new THREE.MeshLambertMaterial({
      color: baseColor
    });
    const socketBase = new THREE.Mesh(socketGeometry, socketMaterial);
    socketGroup.add(socketBase);

    // Furos (padr√£o brasileiro)
    const holeGeometry = new THREE.CylinderGeometry(0.035, 0.035, 0.08, 8);
    const holeMaterial = new THREE.MeshLambertMaterial({
      color: 0x151515
    });

    // Furo superior (terra)
    const hole1 = new THREE.Mesh(holeGeometry, holeMaterial);
    hole1.rotation.x = Math.PI / 2;
    hole1.position.set(0, 0.1, 0.04);
    socketGroup.add(hole1);

    // Furo inferior esquerdo (neutro)
    const hole2 = new THREE.Mesh(holeGeometry, holeMaterial);
    hole2.rotation.x = Math.PI / 2;
    hole2.position.set(-0.1, -0.08, 0.04);
    socketGroup.add(hole2);

    // Furo inferior direito (fase)
    const hole3 = new THREE.Mesh(holeGeometry, holeMaterial);
    hole3.rotation.x = Math.PI / 2;
    hole3.position.set(0.1, -0.08, 0.04);
    socketGroup.add(hole3);

    return socketGroup;
  }

  // Iniciar quando o DOM estiver pronto
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initSimpleViewer);
  } else {
    initSimpleViewer();
  }
</script>